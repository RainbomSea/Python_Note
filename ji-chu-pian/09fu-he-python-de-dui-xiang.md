# 符合Python风格的对象

得益于 **Python** 数据模型，自定义类型的行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（`duck typing`）： 我们只需按照预定行为实现对象所需的方法即可。

## classmethod与staticmethod 

**Python** 教程没有提到 `classmethod` 装饰器，也没有提到 `staticmethod`。学过 **Java** 面向对象编程的人可能觉得奇怪，为什么 **Python** 提供两个这样的装饰器，而不是只提供一个？ 

先来看 `classmethod`的用法：定义操作类，而不是 操作实例的方法。｀classmethod｀ 改变了调用方法的方式，因此类方法 的第一个参数是类本身，而不是实例。｀classmethod｀最常见的用途是定义备选构造方法

`staticmethod` 装饰器也会改变方法的调用方式，但是第一个参数不是 特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体 中，而不是在模块层定义。

示例 9-4 比较 `classmethod` 和 `staticmethod` 的行为 

```py
>>> class Demo: 
...     @classmethod 
...     def klassmeth(*args): 
...         return args  # ➊ 
...     @staticmethod 
...     def statmeth(*args): 
...         return args  # ➋ 
... 
>>> Demo.klassmeth()  # ➌ 
(<class '__main__.Demo'>,) 
>>> Demo.klassmeth('spam') 
(<class '__main__.Demo'>, 'spam') 
>>> Demo.statmeth()   # ➍ 
() 
>>> Demo.statmeth('spam') 
('spam',)
```

❶ `klassmeth` 返回全部位置参数。 

❷ `statmeth` 也是。 

❸ 不管怎样调用 `Demo.klassmeth`，它的第一个参数始终是 `Demo` 类。 

❹ `Demo.statmeth` 的行为与普通的函数相似。

## Python的私有属性和“受保护的”属性 

**Python** 不能像 **Java** 那样使用 `private` 修饰符创建私有属性，但是 **Python** 有个简单的机制，能避免子类意外覆盖“私有”属性。

举个例子。有人编写了一个名为 `Dog` 的类，这个类的内部用到了 `mood` 实例属性，但是没有将其开放。现在，你创建了 `Dog` 类的子 类：`Beagle`。如果你在毫不知情的情况下又创建了名为 `mood` 的实例属性，那么在继承的方法中就会把 `Dog` 类的 `mood` 属性覆盖掉。这是个难以调试的问题。 

为了避免这种情况，如果以 `__mood` 的形式（两个前导下划线，尾部没 有或最多有一个下划线）命名实例属性，**Python** 会把属性名存入实例的 `__dict__` 属性中，而且会在前面加上一个下划线和类名。因此，对 Dog 类来说，`__mood` 会变成 `_Dog__mood`；对 `Beagle` 类来说，会变成 `_Beagle__mood`。这个语言特性叫名称改写（`name mangling`）。 

名称改写是一种安全措施，不能保证万无一失：它的目的是避免意外访问，不能防止故意做错事（图 9-1 也是一种保护装置）。

![Z5flY6.png](https://s2.ax1x.com/2019/07/14/Z5flY6.png)

> 图 9-1：把手上的盖子是种保护装置，而不是安全装置：它能避免意外触动把手，但是不能防止有意转动 

不是所有 **Python** 程序员都喜欢名称改写功能，也不是所有人都喜欢 `self.__x` 这种不对称的名称。有些人不喜欢这种句法，他们约定使用 一个下划线前缀编写“受保护”的属性（如 `self._x`）。批评使用两个下 划线这种改写机制的人认为，应该使用命名约定来避免意外覆盖属性。

**Python** 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多 **Python** 程序员严格遵守的约定，他们不会在类外部访问这种属性。

## 使用 __slots__ 类属性节省空间

默认情况下，**Python** 在各个实例中名为 `__dict__` 的字典里存储实例属 性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，通过 `__slots__` 类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不用字典。

> 继承自超类的 __slots__ 属性没有效果。Python 只会使用 各个类中定义的 __slots__ 属性。 

定义 `__slots__` 的方式是，创建一个类属性，使用 `__slots__` 这个名 字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性

示例 9-11 `vector2d_v3_slots.py`：只在 `Vector2d` 类中添加了 `__slots__` 属性 

```py
class Vector2d:
    __slots__ = ('__x', '__y')
    
    typecode = 'd' # 下面是各个方法（因排版需要而省略了） 
```

在类中定义 `__slots__` 属性的目的是告诉解释器：“这个类中的所有实 例属性都在这儿了！”这样，**Python** 会在各个实例中使用类似元组的结 构存储实例变量，从而避免使用消耗内存的 `__dict__` 属性。如果有数 百万个实例同时活动，这样做能节省大量内存。

> 在类中定义 __slots__ 属性之后，实例不能再有 __slots__ 中所列名称之外的其他属性。这只是一个副作用，不是 __slots__ 存在的真正原因。不要使用 __slots__ 属性禁止类的 用户新增实例属性。__slots__ 是用于优化的，不是为了约束程序 员。 

此外，还有一个实例属性可能需要注意，即 `__weakref__` 属性，为了 让对象支持弱引用（参见 8.6 节），必须有这个属性。用户定义的类中 默认就有 `__weakref__` 属性。可是，如果类中定义了 `__slots__` 属性，而且想把实例作为弱引用的目标，那么要把 `'__weakref__'` 添加到 `__slots__` 中。 