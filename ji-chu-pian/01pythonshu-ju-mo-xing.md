# Python数据模型

## 如何使用特殊方法

* 特殊方法的存在是为了被`Python`解释器调用的,你自己并不需要调用它们.也就是说没有`my_object.__len()__`这种写法,而应该使用`len(my_object)`在执行 `len(my_object)` 的时候，如果 `my_object` 是一个自定义类的对象，那么`Python`会自己去调用其中由 你实现的 `__len__` 方法。 

* 如果是 `Python` 内置的类型，比如列表`（list）`、字符串`（str）`、 字节序列`（bytearray）`等，那么 `CPython` 会抄个近路，`__len__` 实际 上会直接返回 `PyVarObject` 里的 `ob_size` 属性。`PyVarObject` 是表示 内存中长度可变的内置对象的`C`语言结构体。直接读取这个值比调用一个方法要快很多。 

* 很多时候，特殊方法的调用是隐式的，比如 `for i in x:` 这个语句， 背后其实用的是 `iter(x)`，而这个函数的背后则是 `x.__iter__()` 方 法。当然前提是这个方法在 `x` 中被实现了。

* 通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接 调用特殊方法的频率应该远远低于你去实现它们的次数。唯一的例外可 能是 `__init__` 方法，你的代码里可能经常会用到它，目的是在你自己 的子类的 `__init__` 方法中调用超类的构造器。

* 通过内置的函数（例如 `len`、`iter`、`str`，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。

* 不要自己想当然地随意添加特殊方法，比如 `__foo__` 之类的，因为虽 然现在这个名字没有被 `Python` 内部使用，以后就不一定了。 

### 例子

我们来实现一个二维向量（`vector`）类，这里的向量就是欧几里得几何 中常用的概念，常在数学和物理中使用的那个。

![ZlmtPA.png](https://s2.ax1x.com/2019/06/29/ZlmtPA.png)

> 一个二维向量加法的例子，Vector(2,4) + Vextor(2,1) = Vector(4,5)

为了给这个类设计 API，我们先写个模拟的控制台会话来做 doctest。下面这一段代码就是如图所示的向量加法：

![Zlmoa4.png](https://s2.ax1x.com/2019/06/29/Zlmoa4.png)

注意其中的 `+` 运算符所得到的结果也是一个向量，而且结果能被控制台 友好地打印出来。 

`abs` 是一个内置函数，如果输入是整数或者浮点数，它返回的是输入值 的绝对值；如果输入是复数`（complex number）`，那么返回这个复数的模。为了保持一致性，我们的`API`在碰到`abs`函数的时候，也应该返回该向量的模： 

![ZlnpIH.png](https://s2.ax1x.com/2019/06/29/ZlnpIH.png)

Vector 类的实现:


```python
from math import hypot

class Vector:
    def __init(self, x=0, y=0)
        self.x = x
        self.y = y
    
    def __repr__(self):
        return 'Vector(%r, %r)' % (self.x,  slef.y)
    
    def __abs__(self):
        return hypot(self.x, self.y)
    
    def __bool__(self):
        return bool(abs(self))
    
    def __add__(self, other):
        x = self.x + other.x
        y = self.y + other.y
    
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
```

### 字符串的表现形式

**Python**有一个内置的函数叫 `repr`，它能把一个对象用字符串的形式表达出来以便辨认，这就是"字符串表示形式"。`repr` 就是通过 `__repr__` 这个特殊方法来得到一个对象的字符串表示形式的。如果没有实现`__repr__`，当我们在控制台里打印一个向量的实例时，得到的字符串可能会是 `<Vector object at 0x10e100070>`。 

交互式控制台和调试程序（`debugger`）用 `repr` 函数来获取字符串表示 形式；在老的使用`%`符号的字符串格式中，这个函数返回的结果用来代替 `%r` 所代表的对象；同样，`str.format` 函数所用到的新式字符串格式化语法也是利用了`repr`，才把`!r`字段变成字符串。

`__repr__` 所返回的字符串应该准确、无歧义，并且尽可能表达出如何用代码创建出这个被打印的对象。因此这里使用了类似调用对象构造器的表达形式（比如 `Vector(3, 4)` 就是个例子）。 

`__repr__` 和 `__str__` 的区别在于，后者是在`str()`函数被使用，或是在用 `print` 函数打印一个对象的时候才被调用的，并且它返回的字符串对终端用户更友好。

如果你只想实现这两个特殊方法中的一个，`__repr__` 是更好的选择，因为如果一个对象没有`__str__`函数，而 **Python** 又需要调用它的时候，解释器会用 `__repr__`作为替代。

### 算术运算符

通过 `__add__` 和 `__mul__`，为向量类带来了`+`和`*`这两个算术运算符。值得注意的是，这两个方法的返回值都是新创建的向量对象，被操作的两个向量（`self` 或 `other`）还是原封不动，代码里只是读取了它们的值而已。中缀运算符的基本原则就是不改变操作对象，而是产出一个新的值。


### 自定义布尔值

尽管**Python**里有`bool`类型，但实际上任何对象都可以用于需要布尔值的上下文中（比如`if`或`while`语句，或者`and`、`or`和`not`运算符）。为了判定一个值`x` 为真还是为假，**Python**会调用`bool(x)`，这个函数只能返回`True`或者 `False`。

默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对`__bool__`或者 `__len__` 函数有自己的实现。`bool(x)`的背后是调用`x.__bool__()`的结果；如果不存在`__bool__`方法，那么`bool(x)`会尝试调用`x.__len__()`。若返回 `0`，则`bool`会返回`False`；否则返回`True`。 

## 为什么len不是普通方法

--**"实用胜于纯粹"**

如果`x`是一个内置类型的实例，那么`len(x)`的速度会非常快。背后的原因是 **CPython** 会直接从一个`C`结构体里读取对象的长度，完全不会调用任何方法。获取一个集合中元素的数量是一个很常见的操作，在`str`、`list`、`memoryview`等类型上，这个操作必须高效。 

换句话说，`len` 之所以不是一个普通方法，是为了让**Python**自带的数据结构可以走后门，`abs`也是同理。但是多亏了它是特殊方法，我们也可以把`len`用于自定义数据类型。这种处理方式在保持内置类型的效率和 保证语言的一致性之间找到了一个平衡点，也印证了“Python 之禅”中的 另外一句话：“不能让特例特殊到开始破坏既定规则。”










