# 接口：从协议到抽象基类

## 白鹅类型（goose typing）

白鹅类型指，只要 `cls` 是抽象基类，即 `cls` 的元类是 `abc.ABCMeta`，就可以使用 `isinstance(obj, cls)`。
 
与具体类相比，抽象基类有很多理论上的优点.**Python** 的抽象基类还有一个重要的实用优势：可以使用 `register` 类方法在终端用户的代码中把某个类“声明”为一个抽象基类的“虚 拟”子类（为此，被注册的类必须满足抽象基类对方法名称和签名 的要求，最重要的是要满足底层语义契约；但是，开发那个类时不 用了解抽象基类，更不用继承抽象基类）。这大大地打破了严格的 强耦合，与面向对象编程人员掌握的知识有很大出入，因此使用继 承时要小心。 

有时，为了让抽象基类识别子类，甚至不用注册。

其实，抽象基类的本质就是几个特殊方法。例如：

```py
>>> class Struggle: 
...     def __len__(self): return 23 
... 
>>> from collections import abc 
>>> isinstance(Struggle(), abc.Sized) 
True 
```

可以看出，无需注册，`abc.Sized` 也能把 `Struggle` 识别为自己的子类，只要实现了特殊方法 `__len__` 即可（要使用正确的句法和语义实现，前者要求没有参数，后者要求返回一个非负整数，指明对象的长度；如果不使用规定的句法和语义实现特殊方法，如 `__len__`，会导致非常严重的问题）。 

如果实现的类体现了 `numbers`、`collections.abc` 或其他框架中抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册；如果必须检查参数的类型（这是最常见的），例如检查是不是“序列”，那就这样做：  

```py
isinstance(the_arg, collections.abc.Sequence)
```