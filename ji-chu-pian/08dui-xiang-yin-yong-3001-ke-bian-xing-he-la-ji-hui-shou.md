# 对象引用、可变性和垃圾回收

## 变量不是盒子

`Lynn Andrea Stein` 教授 （一位获奖的计算机科学教育工作者，目前在欧林工程学院教书）指出，人们经常使用“变量是盒子”这样的比喻，但是这有碍于理解面向对象语言中的引用式变量。**Python** 变量类似于 **Java** 中的引用式变量，因此 最好把它们理解为附加在对象上的标注。 

在示例 8-1 所示的交互式控制台中，无法使用“变量是盒子”做解释。图 8-1 说明了在 **Python** 中为什么不能使用盒子比喻，而便利贴则指出了变量的正确工作方式。

示例 8-1 变量 `a` 和 `b` 引用同一个列表，而不是那个列表的副本 

```py
>>> a = [1, 2, 3] 
>>> b = a 
>>> a.append(4) 
>>> b 
[1, 2, 3, 4] 
```

![Z41Elj.png](https://s2.ax1x.com/2019/07/13/Z41Elj.png)

> 图 8-1：如果把变量想象为盒子，那么无法解释 Python 中的赋值； 应该把变量视作便利贴，这样示例 8-1 中的行为就好解释了 

Stein 教授还反复讲解了赋值方式。例如讲到 `seesaw` 对象时，她会说“把 变量 `s` 分配给 `seesaw`”，绝不会说“把 `seesaw` 分配给变量 `s`”。对引用式 变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，对象在赋值之前就创建了。

## 标识、相等性和别名

### 在==和is之间选择

== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。 

### 默认做浅复制

复制列表（或多数内置的可变集合）最简单的方式是使用内置的类型构造方法。例如： 

```py
>>> l1 = [3, [55, 44], (7, 8, 9)] 
>>> l2 = list(l1)  ➊ 
>>> l2 
[3, [55, 44], (7, 8, 9)] 
>>> l2 == l1  ➋ 
True 
>>> l2 is l1  ➌ 
False 
```

❶ `list(l1)` 创建 `l1` 的副本。 

❷ 副本与源列表相等。 

❸ 但是二者指代不同的对象。对列表和其他可变序列来说，还能使用简洁的 `l2 = l1[:]` 语句创建副本。 

然而，构造方法或 `[:]` 做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。但是，如果有可变的元素，可能就会导致意想不到的问题。 

在示例 8-6 中，我们为一个包含另一个列表和一个元组的列表做了浅复制，然后做了些修改，看看对引用的对象有什么影响。

```py
l1 = [3, [66, 55, 44], (7, 8, 9)] 
l2 = list(l1)      # ➊ 
l1.append(100)     # ➋ 
l1[1].remove(55)   # ➌ 
print('l1:', l1) 
print('l2:', l2) 
l2[1] += [33, 22]  # ➍ 
l2[2] += (10, 11)  # ➎ 
print('l1:', l1) 
print('l2:', l2) 
```

❶ `l2` 是 `l1` 的浅复制副本。此时的状态如图 8-3 所示。

![Z43OsA.png](https://s2.ax1x.com/2019/07/13/Z43OsA.png)

> 图 8-3：示例 8-6 执行 l2 = list(l1) 赋值后的程序状态。l1 和 l2 指代不同的列表，但是二者引用同一个列表 [66, 55, 44] 和元组 (7, 8, 9)（图表由 Python Tutor 网站生成）

❷ 把 `100` 追加到 `l1` 中，对 `l2` 没有影响。 

❸ 把内部列表 `l1[1]` 中的 `55` 删除。这对 `l2` 有影响，因为 `l2[1]` 绑定的列表与 `l1[1]` 是同一个。

❹ 对可变的对象来说，如 `l2[1]` 引用的列表，`+=` 运算符就地修改列 表。这次修改在 `l1[1]` 中也有体现，因为它是 `l2[1]` 的别名。 

❺ 对元组来说，`+=` 运算符创建一个新元组，然后重新绑定给变量 `l2[2]`。这等同于 `l2[2] = l2[2] + (10, 11)`。现在，`l1` 和 `l2` 中最后位置上的元组不是同一个对象。如图 8-4 所示。

示例 8-6 的输出在示例 8-7 中，对象的最终状态如图 8-4 所示。 

示例 8-7 示例 8-6 的输出 

```py
l1: [3, [66, 44], (7, 8, 9), 100] 
l2: [3, [66, 44], (7, 8, 9)] 
l1: [3, [66, 44, 33, 22], (7, 8, 9), 100] 
l2: [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)] 
```

![Z481y9.png](https://s2.ax1x.com/2019/07/13/Z481y9.png)

> 图 8-4：l1 和 l2 的最终状态：二者依然引用同一个列表对象，现在列表的值是 [66, 44, 33, 22]，不过 l2[2] += (10, 11) 创建一 个新元组，内容是 (7, 8, 9, 10, 11)，它与 l1[2] 引用的元组 (7, 8, 9) 无关（图表由 Python Tutor 网站生成）

## 函数的参数作为引用时 

**Python** 唯一支持的参数传递模式是共享传参（`call by sharing`）。

共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。

这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无 法修改那些对象的标识（即不能把一个对象替换成另一个对象）。示例 8-11 中有个简单的函数，它在参数上调用 `+=` 运算符。分别把数字、列 表和元组传给那个函数，实际传入的实参会以不同的方式受到影响。 

示例 8-11 函数可能会修改接收到的任何可变对象 



















































